<!doctype html>
<html lang="en">
<head>
	<!-- Required meta tags -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<!-- Bootstrap CSS -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
	
	<!-- Font Awesome CSS -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
	
	<!-- highlight.js -->
	<link rel="stylesheet" href="highlight.default.css">
	<script src="highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
	<title>POPL'19 Project Page</title>
</head>
<body>
	<div class="container">
		<h1 class="display-4 text-muted text-center mt-3">
			<a href="https://www.tcs.cs.tu-bs.de/index.html">
				<img src="https://www.tcs.cs.tu-bs.de/images/logo_tcs.png" alt="Institute of Theoretical Computer Science" style="height: 1.0em; margin-top: -.15em;">
			</a>
			POPL'19 Project Page
		</h1>
		<br>

            <!-- <img src="$PREFIX$images/logo_tcs.png" alt="Institute of Theoretical Computer Science"> -->
		
		<!-- ********************************************************************************** -->
		<!-- ************************************** PAPER ************************************* -->
		<!-- ********************************************************************************** -->
		<div class="jumbotron">
			<img src="artifacts_evaluated_reusable.png" class="ml-4 mr-3" style="max-height: 9rem; float: right;">
			<h1 style="font-size: 2.75rem;">
				Decoupling Lock-Free Data Structures from Memory Reclamation for Static Analysis
			</h1>
			<h2>
				<small>
					<a href="https://www.tcs.cs.tu-bs.de/group/meyer/home.html">Roland Meyer</a>
					and
					<a href="https://www.tcs.cs.tu-bs.de/group/wolff/home.html">Sebastian Wolff</a>,
					TU Braunschweig, Germany
				</small>
			</h2>
			<h3>
				<small>
					Accepted for <a href="https://popl19.sigplan.org/home">POPL'19</a>.
				</small>
			</h3>
			<!-- <p class="lead">Accepted for <a href="https://popl19.sigplan.org/home">POPL'19</a>.</p> -->
			<p class="lead text-justify mb-2">
				<strong>Abstract.</strong>
				Verification of concurrent data structures is one of the most challenging tasks in software verification.
				The topic has received considerable attention over the course of the last decade.
				Nevertheless, human-driven techniques remain cumbersome and notoriously difficult while automated approaches suffer from limited applicability.
				The main obstacle for automation is the complexity of concurrent data structures.
				This is particularly true in the absence of garbage collection.
				The intricacy of lock-free memory management paired with the complexity of concurrent data structures makes automated verification prohibitive.
				<br>
				In this work we present a method for verifying concurrent data structures and their memory management separately.
				We suggest two simpler verification tasks that
				imply the correctness of the data structure.
				The first task establishes an over-approximation of the reclamation behavior of the memory management.
				The second task exploits this over-approximation to verify the data structure without the need to consider the implementation of the memory management itself.
				To make the resulting verification tasks tractable for automated techniques, we establish a second result.
				We show that a verification tool needs to consider only executions where a single memory location is reused.
				We implemented our approach and were able to verify linearizability of Michael&amp;Scott's queue and the DGLM queue for both hazard pointers and epoch-based reclamation.
				To the best of our knowledge, we are the first to verify such implementations fully automatically.
			</p>
			<div class="text-right mt-3">
				<a href="http://www.tcs.cs.tu-bs.de/group/wolff/doc/popl19/popl19-MeyerWolff.pdf" class="btn btn-primary text-right">
					<i class="far fa-file-pdf"></i> 
					Paper
				</a>
				<a href="http://www.tcs.cs.tu-bs.de/group/wolff/doc/popl19/popl19-MeyerWolff-slides.pdf" class="btn btn-primary text-right">
					<i class="far fa-file-pdf"></i> 
					Slides
				</a>
				<a href="https://arxiv.org/abs/1810.10807" class="btn btn-primary text-right">
					<i class="far fa-file-pdf"></i> 
					Technical Report
				</a>
				<a href="https://doi.org/10.1145/3290371" class="btn btn-primary text-right">
					<i class="far fa-file-pdf"></i> 
					Paper
				</a>
				<div class="dropdown" style="display: inline-block;">
					<a class="btn btn-primary dropdown-toggle" href="#" role="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
						<i class="fas fa-code"></i>
						Source Code
					</a>
					<div class="dropdown-menu dropdown-menu-right" aria-labelledby="dropdownMenuButton">
						<a class="dropdown-item" href="https://github.com/Wolff09/TMRexp/releases/tag/POPL19-chkds">Verifying lock-free data structures</a>
						<a class="dropdown-item" href="https://github.com/Wolff09/TMRexp/releases/tag/POPL19-chksmr">Verifying memory reclamation</a>
					</div>
				</div>
				<a href="https://www.tcs.cs.tu-bs.de/documents/POPL19Artifact.ova" class="btn btn-primary text-right">
					<i class="fas fa-hdd"></i>
					Virtual Machine
				</a>
			</div>

			<hr class="my-4">
			<p>
				CCS Concepts:
				<strong>• Theory of computation → Data structures design and analysis; Program verification;</strong> Shared memory algorithms; Program specifications; Program analysis;
			</p>
			<p class="mb-4">
				Additional Key Words and Phrases:
				static analysis, lock-free data structures, verification, linearizability, safe memory reclamation, memory management
			</p>
			<p class="mb-0">
				<b>ACM Reference Format:</b><br>
				Roland Meyer and Sebastian Wolff. 2019. Decoupling Lock-Free Data Structures from Memory Reclamation for Static Analysis. <i>Proc. ACM Program. Lang.</i> 3, POPL, Article 58 (January 2019), 31 pages. <a href="https://doi.org/10. 1145/3290371">https://doi.org/10.1145/3290371</a>
			</p>
		</div>
		<br>



		<!-- ********************************************************************************** -->
		<!-- ************************************* TOOLS ************************************** -->
		<!-- ********************************************************************************** -->

		<div class="mt-4">
			<h1>Tool Overview</h1>
			<p>
				Our paper presents an analysis for verifying lock-free data structures that use safe memory reclamation (SMR) techniques.
				We follow a compositional approach which factors out the verification of the SMR implementation.
				Consequently, we have two distinct tools for:
			</p>
			<ul>
				<li><kbd>chkds</kbd> verifying lock-free data structures relative to an SMR specification, and</li>
				<li><kbd>chksmr</kbd> verifying an SMR implementation against an SMR specification.</li>
			</ul>
			<p>
				The SMR specification is given in form of an observer automata (hard coded into our tools).
				For data structures, we verify liniearizability (we assume that programs are annotated with linearization points).
			</p>
			<p>
				We submitted our tool to the <a href="https://popl19.sigplan.org/track/POPL-2019-Artifact-Evaluation">POPL'19 artifact evaluation</a> where it received the <i>Artifact Evaluated -- Reusable</i> badge.
			</p>
			<p>
				In the this page we discuss how to reproduce our experiments.
				Therefore, we walk through the installation, compilation, and benchmarking.
				In the end, we briefly link the concepts and techniques from the paper to our implementation.
			</p>

			<h4>Tool Limitation</h4>
			<p>
				Our tools do not come with a front end (aka parser).
				To analyse programs not included in our benchmarks, one has to compile an appropriate binary first.
				If desired, consider the provided benchmark implementations.
				For example, consider:
				<ul>
					<li><kbd>chkds</kbd> <code>TMRexp-POPL19/test/HP/MichaelScottQueue.cpp</code>, or</li>
					<li><kbd>chksmr</kbd> <code>TMRexp-POPL19/test/HP/Stack.cpp</code>.</li>
				</ul>
				Benchmark program code is constructed in those files using intuitive shortcuts (a complete list can be found in <code>TMRexp-POPL19/src/prog.hpp</code>, lines 655f).
			</p>
		</div>
		<br>


		<!-- ********************************************************************************** -->
		<!-- ************************************* INSTALL ************************************ -->
		<!-- ********************************************************************************** -->

		<div class="mt-4">
			<h1>Installation and Compilation</h1>
			<p>This section describes how to setup your system to repeat the benchmarks from the paper.</p>

			<!-- Quick Start -->
			<div class="alert alert-info container">
					<strong>Quick Start.</strong>
					Download the Virtual Machine Snapshot (created with <a href="https://www.virtualbox.org">Virtual Box</a>, credentials in <code>~/Desktop/pw.txt</code>).
					The artifact is located at <code>~/popl19artifact/</code>.
					The folder <code>~/popl19artifact/Binaries</code> contains executables corresponding to the benchmarks from the paper.
					If you choose this option you can skip the remainder of this section.
			</div>

			<!-- Slow Start -->
			<h4>Download</h4>
			<p>
				The source code can be downloaded from GitHub here:
				<ul>
					<li>
						<kbd>chkds</kbd>
						<a href="https://github.com/Wolff09/TMRexp/releases/tag/POPL19-chkds">
							GitHub release with tag <code>POPL19-chkds</code>
						</a>
					</li>
					<li>
						<kbd>chksmr</kbd>
						<a href="https://github.com/Wolff09/TMRexp/releases/tag/POPL19-chksmr">
							GitHub release with tag <code>POPL19-chksmr</code>
						</a>
					</li>
				</ul>
				<!-- <br>
				<a href="https://github.com/Wolff09/TMRexp/releases/tag/POPL19-chkds" class="btn btn-light btn-sm">
					<i class="fas fa-code"></i>
					Data Structure Verification (release with tag <code>POPL19-chkds</code>)
				</a>
				<a href="https://github.com/Wolff09/TMRexp/releases/tag/POPL19-chksmr" class="btn btn-light btn-sm">
					<i class="fas fa-code"></i>
					SMR Verification (release with tag <code>POPL19-chksmr</code>)
				</a> -->
			</p>
			<p>
				For a unified description of the installation/compilation for both tools, we assume that unzipping yields a folder named <code>TMRexp-POPL19</code>.
			</p>

			<h4>System Requirements</h4>
			<p>
				To compile this project you need <strong>CMake</strong>, a <strong>C++17</strong> compatible compiler, and <strong>Boost multi_array</strong>.
				Compilation was tested with Apple LLVM v.9.1.0, Apple LLVM v.10.0.0, Clang v.5.0, and Clang v.6.0.
			</p>

			<h4>Compilation</h4>
			<p>
				To build the project, simply type make in the root directory of the downloaded sources.
			</p>
			<pre class="bg-light"><code>
					cd path/to/TMRexp-POPL19
					make
			</code></pre>
			<p>This creates a folder <code>build/bin</code> containing all executables.</p>

			<p>Alternatively, you can do the following (for example, to specify the compiler to be used):</p>
			<pre class="bg-light"><code>
					mkdir build
					cd build
					cmake .. -DCMAKE_CXX_COMPILER=/path/to/CXX-compiler
					make
			</code></pre>
			<p>
				Again, folder <code>build/bin</code> contains all executables.
			</p>
		</div>
		<br>
		

		<!-- ********************************************************************************** -->
		<!-- ********************************** BENCHMARKING ********************************** -->
		<!-- ********************************************************************************** -->
		<div class="mt-4">
			<h1>Benchmarking <kbd>chkds</kbd></h1>
			<p>
				We describe how to repeat the benchmarks for verifying lock-free data structures relative to an SMR implementation from the paper.
			</p>

			<!-- Quick Start -->
			<div class="alert alert-info container">
				<strong>Quick Start.</strong>
				Using the VM from above, execute <code>~/popl19artifact/Binaries/&lt;Program&gt;_&lt;SMR&gt;</code> to run the benchmark for <code>Program</code> using <code>SMR</code>.
				When compiling on your own, execute <code>TMRexp-POPL19/build/bin/&lt;Program&gt;_&lt;SMR&gt;</code> (for the DGLM Queue see the discussion below).
			</div>

			<!-- Slow Start -->

			<h4>Benchmark Programs</h4>
			<p>
				We evaluated our tool on a <i>Coarse Stack</i>, a <i>Coarse Queue</i>, <i>Treiber's Stack</i>, <i>Michael&amp;Scott's Queue</i>, and the <i>DGLM queue</i> using <i>no SMR (<code>N</code>)</i>, <i>No Reclamation/Garbage Collection (<code>G</code>)</i>, <i>Hazard Pointers (<code>H</code>)</i>, and <i>Epoch-Based Reclamation (<code>E</code>)</i>.
				C-style pseudo code is given in the following.
				We mark lines that are required only for a specific SMR by the aforementioned letters <code>N</code>, <code>G</code>, <code>H</code>, and <code>E</code>.
			</p>
			<nav>
				<div class="nav nav-tabs" id="nav-tab" role="tablist">
					<a class="nav-item nav-link active" id="nav-CS-tab" data-toggle="tab" href="#nav-CS" role="tab" aria-controls="nav-CS" aria-selected="true">Coarse Stack</a>
					<a class="nav-item nav-link" id="nav-CQ-tab" data-toggle="tab" href="#nav-CQ" role="tab" aria-controls="nav-CQ" aria-selected="false">Coarse Queue</a>
					<a class="nav-item nav-link" id="nav-TS-tab" data-toggle="tab" href="#nav-TS" role="tab" aria-controls="nav-TS" aria-selected="false">Treiber's Stack</a>
					<a class="nav-item nav-link" id="nav-OTS-tab" data-toggle="tab" href="#nav-OTS" role="tab" aria-controls="nav-OTS" aria-selected="false">Opt. Treiber's Stack</a>
					<a class="nav-item nav-link" id="nav-MS-tab" data-toggle="tab" href="#nav-MS" role="tab" aria-controls="nav-MS" aria-selected="false">Michael&amp;Scott's Queue</a>
					<a class="nav-item nav-link" id="nav-DGLM-tab" data-toggle="tab" href="#nav-DGLM" role="tab" aria-controls="nav-DGLM" aria-selected="false">DGLM Queue</a>
				</div>
			</nav>
			<div class="tab-content bg-light" id="nav-tabContent">
				<div class="tab-pane show active" id="nav-CS" role="tabpanel" aria-labelledby="nav-CS-tab">
					<pre><code>
      // binary name: CoarseStack_GC, CoarseStack_NoSMR

      struct Node {
          data_t data;
          Node* next;
      };
      
      shared Node* ToS;
      
      atomic init() {
          ToS = NULL;
      }
      
      void push(data_t input) {
          Node* node = new Node();
          node->data = input;
          atomic {
              node->next = ToS;
              ToS = node;
          }
      }
      
      data_t pop() {
          atomic {
              Node* top = ToS;
              if (top == NULL) return EMPTY;
              data_t output = top->data;
              ToS = Tos->next;
<i>  <span class="text-danger">GN</span>          retire(top);</i>
              return output;
          }
      }
					</code></pre>
				</div>
				<div class="tab-pane" id="nav-CQ" role="tabpanel" aria-labelledby="nav-CQ-tab">
					<pre><code>
      // binary name: CoarseQueue_GC, CoarseQueue_NoSMR

      struct Node {
          data_t data;
          Node* next;
      };
      
      shared Node* Head, Tail;
      
      atomic init() {
          Head = new Node();
          Head->next = NULL;
          Tail = Head;
      }
      
      void enqueue(data_t input) {
          Node* node = new Node();
          node->data = input;
          node->next = NULL;
          atomic {
              Tail->next = node;
              Tail = node;
          }
      }
      
      data_t dequeue() {
          atomic {
              Node* head = Head;
              Node* next = head->next;
              if (next == NULL) return EMPTY;
              data_t output = next->data;
              Head = next;
<i>  <span class="text-danger">GN</span>          retire(head);</i>
              return output;
          }
      }
					</code></pre>
				</div>
				<div class="tab-pane" id="nav-TS" role="tabpanel" aria-labelledby="nav-TS-tab">
					<pre><code>
      // binary name: TreibersStack_GC, TreibersStack_EBR, TreibersStack_HP

      struct Node {
          data_t data;
          Node* next;
      };
      
      shared Node* ToS;
      
      atomic init() {
          ToS = NULL;
      }
      
      void push(data_t input) {
<i>  <span class="text-danger">E</span>       leaveQ();</i>
          Node* node = new Node();
          node->data = input;
          while (true) {
              Node* top = ToS;
<i>  <span class="text-danger">H</span>           protect(top, 0);</i>
<i>  <span class="text-danger">H</span>           if (top != ToS) continue;</i>
              node->next = top;
              if (CAS(&ToS, top, node))
                  break
          }
<i>  <span class="text-danger">H</span>       unprotect(0);</i>
<i>  <span class="text-danger">E</span>       enterQ();</i>
      }
      
      data_t pop() {
<i>  <span class="text-danger">E</span>       leaveQ();</i>
          while (true) {
              Node* top = ToS;
              if (top == NULL) return EMPTY;
<i>  <span class="text-danger">H</span>           protect(top, 0);</i>
<i>  <span class="text-danger">H</span>           if (top != ToS) continue;</i>
              Node* next = top->next;
              if (CAS(&ToS, top, next)) {
                  data_t output = top->data;
<i>  <span class="text-danger">HEG</span>             retire(top);</i>
<i>  <span class="text-danger">H</span>               unprotect(0);</i>
<i>  <span class="text-danger">E</span>               enterQ();</i>
                  return output;
              }
          }
      }
					</code></pre>
				</div>
				<div class="tab-pane" id="nav-OTS" role="tabpanel" aria-labelledby="nav-OTS-tab">
					<pre><code>
      // binary name: OptTreibersStack_HP

      struct Node {
          data_t data;
          Node* next;
      };
      
      shared Node* ToS;
      
      atomic init() {
          ToS = NULL;
      }
      
      void push(data_t input) {
          Node* node = new Node();
          node->data = input;
          while (true) {
              Node* top = ToS;
              node->next = top;
              if (CAS(&ToS, top, node))
                  break
          }
      }
      
      data_t pop() {
          while (true) {
              Node* top = ToS;
              if (top == NULL) return EMPTY;
<i>  <span class="text-danger">H</span>           protect(top, 0);</i>
<i>  <span class="text-danger">H</span>           if (top != ToS) continue;</i>
              Node* next = top->next;
              if (CAS(&ToS, top, next)) {
                  data_t output = top->data;
<i>  <span class="text-danger">H</span>               retire(top);</i>
<i>  <span class="text-danger">H</span>               unprotect(0);</i>
                  return output;
              }
          }
      }
					</code></pre>
				</div>
				<div class="tab-pane" id="nav-MS" role="tabpanel" aria-labelledby="nav-MS-tab">
					<pre><code>
      // binary name: MichaelScottQueue_GC, MichaelScottQueue_EBR, MichaelScottQueue_HP

      struct Node {
          data_t data;
          Node* next;
      };
      
      shared Node* Head, Tail;
      
      atomic init() {
          Head = new Node();
          Head->next = NULL;
          Tail = Head;
      }
      
      void enqueue(data_t input) {
<i>  <span class="text-danger">E</span>       leaveQ;</i>
          Node* node = new Node();
          node->data = input;
          node->next = NULL;
          while (true) {
              Node* tail = Tail;
<i>  <span class="text-danger">H</span>           protect(tail, 0);</i>
<i>  <span class="text-danger">H</span>           if (tail != Tail) continue;</i>
              Node* next = tail->next;
              if (tail != Tail) continue;
              if (next != NULL) {
                  CAS(&Tail, tail, next);
                  continue;
              }
              if (CAS(&tail->next, next, node))
                  break
          }
          CAS(&Tail, tail, node);
<i>  <span class="text-danger">E</span>       enterQ;</i>
<i>  <span class="text-danger">H</span>       unprotect(0);</i>
      }
      
      data_t dequeue() {
<i>  <span class="text-danger">E</span>       leaveQ;</i>
          while (true) {
              Node* head = Head;
<i>  <span class="text-danger">H</span>           protect(head, 0);</i>
<i>  <span class="text-danger">H</span>           if (head != Head) continue;</i>
              Node* tail = Tail;
              Node* next = head->next;
<i>  <span class="text-danger">H</span>           protect(next, 1);</i>
              if (head != Head) continue;
              if (next == NULL) return EMPTY;
              if (head == tail) {
                  CAS(&Tail, tail, next);
                  continue;
              } else {
                  data_t output = next->data;
                  if (CAS(&Head, head, next)) {
<i>  <span class="text-danger">HEG</span>             retire(head);</i>
<i>  <span class="text-danger">E</span>                   enterQ;</i>
<i>  <span class="text-danger">H</span>                   unprotect(0);</i>
<i>  <span class="text-danger">H</span>                   unprotect(1);</i>
                      return output;
                  }
              }
          }
      }
					</code></pre>
				</div>
				<div class="tab-pane" id="nav-DGLM" role="tabpanel" aria-labelledby="nav-DGLM-tab">
					<pre><code>
      // binary name: DGLMQueue_GC, DGLMQueue_EBR, DGLMQueue_HP

      struct Node {
          data_t data;
          Node* next;
      };
      
      shared Node* Head, Tail;
      
      atomic init() {
          Head = new Node();
          Head->next = NULL;
          Tail = Head;
      }
      
      void enqueue(data_t input) {
<i>  <span class="text-danger">E</span>       leaveQ;</i>
          Node* node = new Node();
          node->data = input;
          node->next = NULL;
          while (true) {
              Node* tail = Tail;
<i>  <span class="text-danger">H</span>           protect(tail, 0);</i>
<i>  <span class="text-danger">H</span>           if (tail != Tail) continue;</i>
              Node* next = tail->next;
              if (tail != Tail) continue;
              if (next != NULL) {
                  CAS(&Tail, tail, next);
                  continue;
              }
              if (CAS(&tail->next, next, node))
                  break
          }
          CAS(&Tail, tail,node);
<i>  <span class="text-danger">H</span>       unprotect(0);</i>
<i>  <span class="text-danger">E</span>       enterQ;</i>
      }
      
      data_t dequeue() {
<i>  <span class="text-danger">E</span>       leaveQ;</i>
          while (true) {
              Node* head = Head;
<i>  <span class="text-danger">H</span>           protect(head, 0);</i>
<i>  <span class="text-danger">H</span>           if (head != Head) continue;</i>
              Node* next = head->next;
<i>  <span class="text-danger">H</span>           protect(next, 1);</i>
              if (head != Head) continue;
              if (next == NULL) return EMPTY;
              data_t output = next->data;
              if (CAS(&Head, head, next)) {
                  Node* tail = Tail;
                  if (head == tail) {
                      CAS(Tail, tail, next);
                  }
<i>  <span class="text-danger">HEG</span>             retire(head);</i>
<i>  <span class="text-danger">H</span>               unprotect(0);</i>
<i>  <span class="text-danger">H</span>               unprotect(1);</i>
<i>  <span class="text-danger">E</span>               enterQ;</i>
                  return output;
              }
          }	
      }
					</code></pre>
				</div>
			</div>
			
			<h4>Running Benchmarks</h4>
			<p>
				To run the benchmarks got to the <code>build/bin/</code> folder and execute the corresponding binary.
				The naming scheme is <code>&lt;DS&gt;_&lt;SMR&gt;</code> where <code>&lt;DS&gt;</code> is the name of the benchmark program and <code>&lt;SMR&gt;</code> is the reclamation scheme.
			</p>
			<p>
				For example, to benchmark the running example from the paper, Michael&amp;Scott's Queue using Hazard Pointers (HP), you have to do the following:
			</p>
			<pre class="bg-light"><code>
				cd path/to/TMRexp-POPL19/build/bin
				./MichaelScottQueue_HP
			</code></pre>

			<h4>The DGLM Queue</h4>
			<p>
				As stated in the paper, the implemented shape abstraction requires hints to verify the DGLM Queue.
				To enable/disable hinting you have to set the corresponding flag in <code>src/config.hpp</code> and recompile the tool.
				More precisely, you have to change line 22 from
			</p>
			<pre><code>
				#define DGLM_HINT false
			</code></pre>
			<p>
				to
			</p>
			<pre><code>
				#define DGLM_HINT true
			</code></pre>
			<p>
				Beware: using <code>DGLM_HINT=true</code> with any benchmark other than the DGLM Queue exhibits undefined behavior!
			</p>
			<p>
				For users of the VM image: the folder <code>~/popl19artifact/Binaries/</code> already contains the properly compiled binaries.
				The binaries where compiled from <code>~/popl19artifact/chkds/</code> and <code>~/popl19artifact/chkds-DGLM/</code> for all benchmarks except the DGLM Queue and the DGLM Queue, respectively.
			</p>
			
			<h4>Expected Benchmarks Results</h4>
			<p>
				As reported in the paper, running the benchmarks on an Intel Xeon X5650@2.67GHz with Ubuntu 16.04 and using Clang version 5.0 we expect the following running times and verification results.
			</p>
			<table class="table">
				<thead>
					<tr>
						<th scope="col">Program</th>
						<th scope="col">SMR</th>
						<th class="text-right" scope="col">Time Verif.</th>
						<th class="text-right" scope="col">States</th>
						<th class="text-right" scope="col">ABAs</th>
						<th class="text-right" scope="col">Time ABA</th>
						<th class="text-center" scope="col">Linearizable</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<th scope="row" rowspan="2">Coarse Stack</th>
						<td>GC</td>
						<td class="text-right">0.44s</td>
						<td class="text-right">300</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<td>None</td>
						<td class="text-right">0.5s</td>
						<td class="text-right">300</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<th scope="row" rowspan="2">Coarse Queue</th>
						<td>GC</td>
						<td class="text-right">1.7s</td>
						<td class="text-right">300</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<td>None</td>
						<td class="text-right">1.7s</td>
						<td class="text-right">300</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<th scope="row" rowspan="3">Treiber's Stack</th>
						<td>GC</td>
						<td class="text-right">3.2s</td>
						<td class="text-right">806</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<td>EBR</td>
						<td class="text-right">16s</td>
						<td class="text-right">1822</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<td>HP</td>
						<td class="text-right">19s</td>
						<td class="text-right">2606</td>
						<td class="text-right">186</td>
						<td class="text-right">0.06s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<th scope="row">Opt. Treiber's Stack</th>
						<td>HP</td>
						<td class="text-right">0.8s</td>
						<td class="text-right">-</td>
						<td class="text-right">-</td>
						<td class="text-right">-</td>
						<td class="text-center">no<sup>*</sup></td>
					</tr>
					<tr>
						<th scope="row" rowspan="3">Michael&amp;Scott's Queue</th>
						<td>GC</td>
						<td class="text-right">414s</td>
						<td class="text-right">2202</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<td>EBR</td>
						<td class="text-right">2630s</td>
						<td class="text-right">7613</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<td>HP</td>
						<td class="text-right">7075s</td>
						<td class="text-right">19028</td>
						<td class="text-right">536</td>
						<td class="text-right">0.9s</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<th scope="row" rowspan="3">DGLM Queue</th>
						<td>GC</td>
						<td class="text-right">714s</td>
						<td class="text-right">9934</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes<sup>**</sup></td>
					</tr>
					<tr>
						<td>EBR</td>
						<td class="text-right">3754s</td>
						<td class="text-right">27132</td>
						<td class="text-right">0</td>
						<td class="text-right">0s</td>
						<td class="text-center">yes<sup>**</sup></td>
					</tr>
					<tr>
						<td>HP</td>
						<td class="text-right">7010s</td>
						<td class="text-right">41753</td>
						<td class="text-right">2824</td>
						<td class="text-right">26s</td>
						<td class="text-center">yes<sup>**</sup></td>
					</tr>
				</tbody>
			</table>
			<p>
				<sup>*</sup> Pointer Race due to an ABA in <code>push</code> makes the verification fail.
				<br>
				<sup>**</sup> Imprecision in the heap abstraction required hinting that <code>Head</code> cannot overtake <code>Tail</code> by more than one node.
			</p>
		</div>
		<br>
		

		<!-- ********************************************************************************** -->
		<!-- ********************************** BENCHMARKING ********************************** -->
		<!-- ********************************************************************************** -->
		<div class="mt-4">
			<h1>Benchmarking <kbd>chksmr</kbd></h1>
			<p>
				We describe how to repeat the benchmarks for verifying SMR implementations from the paper.
			</p>

			<!-- Quick Start -->
			<div class="alert alert-info container">
				<strong>Quick Start.</strong>
				Using the VM from above, execute <code>~/popl19artifact/Binaries/&lt;SMR&gt;</code> to run the benchmark for the SMR implementation <code>SMR</code>.
				When compiling on your own, execute <code>TMRexp-POPL19/build/bin/&lt;SMR&gt;</code>.
			</div>

			<!-- Slow Start -->

			<h4>Benchmark Programs</h4>
			<p>
				We evaluated our tool on an <i>Hazard Pointer (HP)</i> and an <i>Epoch-based Reclamation (EBR)</i> implementation both of which support dynamic joining/parting of threads.
				C-style pseudo code is given in the following.
			</p>
			<nav>
				<div class="nav nav-tabs" id="nav-tab" role="tablist">
					<a class="nav-item nav-link active" id="nav-HP-tab" data-toggle="tab" href="#nav-HP" role="tab" aria-controls="nav-HP" aria-selected="true">Hazard Pointers</a>
					<a class="nav-item nav-link" id="nav-EBR-tab" data-toggle="tab" href="#nav-EBR" role="tab" aria-controls="nav-EBR" aria-selected="false">Epoch-based Reclamation</a>
				</div>
			</nav>
			<div class="tab-content bg-light" id="nav-tabContent">
				<div class="tab-pane show active" id="nav-HP" role="tabpanel" aria-labelledby="nav-HP-tab">
					<pre><code>
      // binary name: HPimpl

      struct HPRec {
          HPRec* next;
          void* hp0;
          void* hp1;
      };
      
      shared HPRec* Records;
      threadlocal HPRec* myRec;
      threadlocal List&lt;void*&gt; retiredList;
      
      atomic init() {
          Records = NULL;
      }

      void join() {
          myRec = new HPRec();
          while (true) {
              HPRec* rec = Records;
              myRec->next = rec;
              if (CAS(Records, rec, myRec)) {
                  break;
              }
          }
          myRec->hp0 = NULL;
          myRec->hp1 = NULL;
      }

      void part() {
          unprotect(0);
          unprotect(1);
      }

      void protect0(void* ptr) {
          myRec->hp0 = ptr;
      }
      
      void protect1(void* ptr) {
          myRec->hp1 = ptr;
      }
      
      void unprotect0() {
          myRec->hp0 = NULL;
      }
      
      void unprotect1() {
          myRec->hp1 = NULL;
      }
      
      void retire(void* ptr) {
          if (ptr != NULL) {
              retiredList.add(ptr);
          }
          if (*) {
              reclaim();
          }
      }
      
      void reclaim() {
          List&lt;void*&gt; protectedList;
          HPRec* cur = Records;
          while (cur != NULL) {
              void* hp0 = cur->hp0;
              void* hp1 = cur->hp1;
              protectedList.add(hp0);
              protectedList.add(hp1);
              cur = cur->next();
          }
          List&lt;void*&gt; freeList = retiredList.copy();
          freeList = freeList.remove_all(protectedList);
          retiredList = retiredList.remove_all(freeList);
          free_all(freeList);
      }

      void free_all(List&lt;void*&gt; list) {
          for (void* ptr : list) {
              free(ptr);
          }
      }
					</code></pre>
				</div>
				<div class="tab-pane" id="nav-EBR" role="tabpanel" aria-labelledby="nav-EBR-tab">
					<pre><code>
      // binary name: EBRimpl

      enum epoch_t { 0, 1, 2 };

      struct EBRRec {
          EBRRec* next;
          epoch_t epoch;
      };
      
      shared EBRRec* Records;
      shared epoch_t Epoch;
      threadlocal EBRRec* myRec;
      threadlocal List&lt;void*&gt; bag0;
      threadlocal List&lt;void*&gt; bag1;
      threadlocal List&lt;void*&gt; bag2;
      
      atomic init() {
          Records = NULL;
          Epoch = 0;
      }

      void join() {
          myRec = new EBRRec();
          while (true) {
              EBRRec* rec = Records;
              myRec->next = rec;
              if (CAS(Records, rec, myRec)) {
                  break;
              }
          }
          myEpoch = Epoch;
          myRec->epoch = myEpoch;
      }

      void part() {
      }

      void enterQ() {
      }
      
      void leaveQ() {
          if (*) { 
              if (myEpoch != Epoch) { 
                  free_all(bag2);
                  bag2 = bag1;
                  bag1 = bag0;
                  bag0 = List&lt;void*&gt;::empty();
                  myEpoch = Epoch;
                  myRec->epoch = myEpoch;
              }

              EBRrec* cur = Records;
              while (cur != NULL) {
                  if (epoch != cur->epoch) {
                      break;
                  }
                  cur = cur->next;
              }
              CAS(Epoch, epoch, (epoch + 1) % 3);
          }

      }
      
      void retire(void* ptr) {
          bag0.add(ptr);
      }

      void free_all(List&lt;void*&gt; list) {
          for (void* ptr : list) {
              free(ptr);
          }
      }
					</code></pre>
				</div>
			</div>
			
			<h4>Running Benchmarks</h4>
			<p>
				To run the benchmarks got to the <code>build/bin/</code> folder and execute the corresponding binary.
				The naming scheme is <code>&lt;SMR&gt;_&lt;Info&gt;</code> where <code>&lt;SMR&gt;</code> is the (abbreviated) name of the benchmark program and <code>&lt;Info&gt;</code> is a description of the implementation (we have various implementations for each class).
			</p>
			<p>
				For example, to benchmark the running example from the paper, the Hazard Pointer implementation, you have to do the following:
			</p>
			<pre class="bg-light"><code>
				cd path/to/TMRexp-POPL19/build/bin
				./HPimpl
			</code></pre>
			
			<h4>Expected Benchmarks Results</h4>
			<p>
				As reported in the paper, running the benchmarks on an Intel Xeon X5650@2.67GHz with Ubuntu 16.04 and using Clang version 5.0 we expect the following running times and verification results.
			</p>
			<table class="table">
				<thead>
					<tr>
						<th scope="col">Program</th>
						<th scope="col">Observer</th>
						<th class="text-right" scope="col">Time</th>
						<th class="text-right" scope="col">States</th>
						<th class="text-center" scope="col">Correct</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<th scope="row" >Hazard Pointers</th>
						<td><i>O<sub>Base</sub> x O<sub>HP</sub></i></td>
						<td class="text-right">1.5s</td>
						<td class="text-right">5437</td>
						<td class="text-center">yes</td>
					</tr>
					<tr>
						<th scope="row">Epoch-based Reclamation</th>
						<td><i>O<sub>Base</sub> x O<sub>EBR</sub></i></td>
						<td class="text-right">11.2s</td>
						<td class="text-right">11528</td>
						<td class="text-center">yes</td>
					</tr>
				</tbody>
			</table>
		</div>
		<br>



		<!-- ********************************************************************************** -->
		<!-- ************************************* OUTPUT ************************************* -->
		<!-- ********************************************************************************** -->

		<div class="mt-4">
			<h1>Tool Output</h1>
			<p>
				When executing a binary from above, our tool prints the following:
			</p>
			<ol>
				<li>The input program</li>
				<li>Progress of the fixed point computation</li>
				<li>Verification verdict</li>
				<li>Summary (gist)</li>
			</ol>
			<p>
				For an example, the output of <kbd>chsmr</kbd> <code>HPimpl</code> has the following form:
			</p>
			<pre><code>
      post image...     [#enc] done! [#enc=0.9k, #step=0k, #steptotal=0k]
      interference...   [32 buckets][#bucketsize][198][129][130][129][4][59][59][59][105][105][70][70][4][59][59][59][59][59][17][17][105][105][59][59][101][37][70][70][17][17][37][67] done! [#enc=2.2k, #step=85k, #steptotal=40k]
      post image...     [#enc][2k][3k][4k][4k] done! [#enc=5.0k, #step=4k, #steptotal=5k]
      interference...   [32 buckets][#bucketsize][274][253][255][253][79][156][156][156][223][223][157][159][79][156][156][156][154][154][93][95][223][223][154][154][217][107][157][157][93][93][105][153] done! [#enc=5.2k, #step=172k, #steptotal=96k]
      post image...     [#enc] done! [#enc=5.4k, #step=0k, #steptotal=5k]
      interference...   [32 buckets][#bucketsize][274][253][255][253][156][156][156][156][223][223][159][159][156][156][156][156][154][154][95][95][223][223][154][154][217][135][157][157][93][93][133][153] done! [#enc=5.4k, #step=173k, #steptotal=151k]
      post image...     [#enc] done! [#enc=5.4k, #step=0k, #steptotal=5k]
      interference...   [32 buckets][#bucketsize][274][253][255][253][156][156][156][156][223][223][159][159][156][156][156][156][154][154][95][95][223][223][154][154][217][135][157][157][93][93][133][153] done! [#enc=5.4k, #step=173k, #steptotal=207k]
			</code></pre>
			<p>
				The output tells you that sequential steps (<code>post image...</code>) and interference steps (<code>interference...</code>) are executed in rounds.
				Sequential steps print the current size of the fixed point in regular intervals.
				For example, in the third line we have <code>[#enc][2k]</code> meaning that there are 2000 views at the time of the output.
				Interference steps print the number of <i>buckets</i>.
				The explored views are stored in buckets to reduce the search space of interference steps.
				Views from different buckets are guaranteed to not match, i.e., are guaranteed to not require interference.
				In the second line, for example, we have <code>[32 buckets][#bucketsize][274]</code>.
				This states that there are 32 different buckets and that the first bucket contains 274 views.
			</p>
			<p>
				The remaining output is straight forward.
			</p>
		</div>
		<br>
		

		<!-- ********************************************************************************** -->
		<!-- ********************************* IMPLEMENTATION ********************************* -->
		<!-- ********************************************************************************** -->
		<div class="mt-4">
			<h1>Notes on the Implementation</h1>
			<p>
				The following tables relate (informal) descriptions of the implemented analysis from the paper to the implementation.
			</p>

			<h4 class="mb-3">General <kbd>chkds</kbd> <kbd>chksmr</kbd></h4>
			<table class="table">
				<thead>
					<tr>
						<th scope="col">Paper</th>
						<th scope="col">Implementation</th>
						<th scope="col">Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td scope="row">Views</td>
						<td><code class="text-nowrap">src/cfg.hpp</code></td>
						<td class="text-justify">
							Views are implemented by the class <code>Cfg</code>.
							They carry, among other things, a <i>shape abstraction</i> of the memory, <i>validity information</i>, and <i>observer states</i>.
						</td>
					</tr>
					<tr>
						<td scope="row"><span class="text-nowrap">Thread-modular</span> fixed point</td>
						<td><code class="text-nowrap">src/fixpoint.cpp</code></td>
						<td class="text-justify">
							The fixed point computation maintains a collection of views the post image of which may not have been explored.
							The post image of these views is computed and added to the fixed point.
							The implementation proceeds in rounds.
							In each round <i>sequential steps</i> are performed exhaustively first and then <i>interference steps</i> are applied.
							<br>
							(There is an alternative fixed point computation using a work list approach.
							It can be activated by setting the <code>WORKLIST_INTERFERENCE</code> to <code>true</code> in the configuration file.)
						</td>
					</tr>
					<tr>
						<td scope="row" rowspan="2">Shape abstraction</td>
						<td><code class="text-nowrap">src/shape.hpp</code></td>
						<td class="text-justify">
							Class <code>Shape</code> implements a container for a shape abstraction of a specific memory layout.
							More details on the shape abstraction can be found in Abdulla et al. [<a href="https://link.springer.com/chapter/10.1007/978-3-642-36742-7_23">2013</a>,<a href="https://link.springer.com/article/10.1007/s10009-016-0415-4">2017</a>].
						</td>
					</tr>
					<tr>
						<td><code class="text-nowrap">src/post/*.cpp</code></td>
						<td class="text-justify">
							Contains post-image computation for the shape abstraction for every supported statement type.
						</td>
					</tr>
					<tr>
						<td scope="row">Interference</td>
						<td><code class="text-nowrap">src/fixp/interference.cpp</code></td>
						<td class="text-justify">
							Implements <i>interference steps</i>.
							Such a step considers all pairs of previously explored views, combines them into a two-thread view, computes a post image for one of the threads, and projects the result to the other thread.
							The resulting views are added to the fixed point.
						</td>
					</tr>
					<tr>
						<td scope="row" rowspan="2">Observers</td>
						<td><code class="text-nowrap">src/observer.hpp</code></td>
						<td class="text-justify">
							Class <code>Observer</code> implements observer automata as presented in the paper.
						</td>
					</tr>
					<tr>
						<td><code class="text-nowrap">test/ObserverFactory.hpp</code></td>
						<td class="text-justify">
							Creates observer instances along the lines of the paper.
							<!-- The implementation relies on <i>Lemma 6.1</i>, thus does not check if the observer <i>supports elision (Definition 5.14)</i>. -->
						</td>
					</tr>
				</tbody>
			</table>

			<h4 class="mb-3">Data Structure Verification <kbd>chkds</kbd></h4>
			<table class="table">
				<thead>
					<tr>
						<th scope="col">Paper</th>
						<th scope="col">Implementation</th>
						<th scope="col">Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td scope="row">Views</td>
						<td><code class="text-nowrap">src/cfg.hpp</code></td>
						<td class="text-justify">
							Besides the above, also stores <i>freedness information</i> of the single reusable cell.
						</td>
					</tr>
					<tr>
						<td scope="row">Elision support</td>
						<td><code class="text-nowrap">test/ObserverFactory.hpp</code></td>
						<td class="text-justify">
							The implementation relies on <i>Lemma 6.1</i>, thus does not check if the observer <i>supports elision (Definition 5.14)</i>.
						</td>
					</tr>
					<tr>
						<td scope="row">Environment <code>free</code></td>
						<td><code class="text-nowrap">src/post/mem.cpp</code></td>
						<td class="text-justify">
							Following the semantics for <i>environment frees</i>, <i>rule (Free)</i>, the implementation checks which frees can be executed by checking whether the observer reaches a final state upon consuming a free event.
						</td>
					</tr>
					<tr>
						<td scope="row">Reallocation of a single address</td>
						<td><code class="text-nowrap">src/post/mem.cpp</code></td>
						<td class="text-justify">
							To identify the single address available for reuse, shapes carry a special <i>ghost pointer</i> to the reusable cell.
							Moreover, views carry a flag stating whether or not the cell is freed.
							If so, an allocation can yield a pointer to that cell.
							Otherwise, the allocation can only yield fresh cells.
						</td>
					</tr>
					<tr>
						<td scope="row" rowspan="2">Validity</td>
						<td><code class="text-nowrap">src/cfg.hpp</code></td>
						<td class="text-justify">
							Views (class <code>Cfg</code>) carry validity information about pointers.
						</td>
					</tr>
					<tr>
						<td><code class="text-nowrap">src/post/*.cpp</code></td>
						<td class="text-justify">
							The post image operator updates the validity according to the definition in the paper.
						</td>
					</tr>
					<tr>
						<td scope="row">Pointer race check</td>
						<td><code class="text-nowrap">src/post.cpp</code></td>
						<td class="text-justify">
							The post image operators check whether an unsafe access or a racy SMR call is performed.
							The latter relies on <i>Lemma 6.2</i> and deems racy calls to <code>retire</code> that use an invalid pointer.
						</td>
					</tr>
					<tr>
						<td scope="row">Harmful ABA check</td>
						<td><code class="text-nowrap">src/chkaware.cpp</code></td>
						<td class="text-justify">
							Checks for every view where an invalid pointer can be compared in an <code>assert</code> for harmful ABAs.
							The implementation follows the description in the paper.
						</td>
					</tr>
				</tbody>
			</table>

			<h4 class="mb-3">SMR Verification <kbd>chksmr</kbd></h4>
			<table class="table">
				<thead>
					<tr>
						<th scope="col">Paper</th>
						<th scope="col">Implementation</th>
						<th scope="col">Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td scope="row">Views</td>
						<td><code class="text-nowrap">src/cfg.hpp</code></td>
						<td class="text-justify">
							Besides the above, also stores data (set) abstractions.
						</td>
					</tr>
					<tr>
						<td scope="row">Retain records</code></td>
						<td><code class="text-nowrap">src/shape.hpp</code></td>
						<td class="text-justify">
							Stores the <code>myRecord</code> pointer of a non-view thread.
						</td>
					</tr>
					<tr>
						<td scope="row" rowspan="2">Last <code>retire</code></td>
						<td><code class="text-nowrap">test/ObserverFactory.hpp</code></td>
						<td class="text-justify">
							Introduces redundant observer locations to judge whether or not the observed thread performed the last <code>retire</code> call.
						</td>
					</tr>
					<tr>
						<td><code class="text-nowrap">src/fixp/interference.cpp</code></td>
						<td class="text-justify">
							Prunes interference among views for identical threads.
						</td>
					</tr>
					<tr>
						<td scope="row">Data (set) abstraction</td>
						<td><code class="text-nowrap">src/post/*.cpp</code></td>
						<td class="text-justify">
							Contains post-image computation for the data abstraction for every supported statement type.
						</td>
					</tr>
				</tbody>
			</table>
		</div>

		<br><br><br>
	</div>



	<!-- Optional JavaScript -->
	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
</body>
</html>
